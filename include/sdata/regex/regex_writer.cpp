#include "regex_writer.hpp"
#include "regex_automata.hpp"

namespace sdata {

RegexWriter::RegexWriter(const RegexAutomata &automata) : m_automata(automata) {
  write_graphviz();
}

void RegexWriter::write_graphviz() {
  constexpr static std::string_view CREDITS =
    "# Regex graph autogenerated by https://github.com/douidik/sdata \n"
    "# <$>: epsilon state \n"
    "# <^>: any state \n"
    "# <_>: empty \n"
    "# <?>: non-printable state \n";

  write("{}\n", CREDITS);
  write("digraph regex_automata {{\n");

  if (!m_automata.empty()) {
    write_root();
    write_shapes();
    write_edges();
  } else {
    write("\t#Empty automata");
  }

  write("}}");
}

void RegexWriter::write_root() {
  write("\trankdir = LR;\n");
  write("\tstart [shape = box];\n");
  write("\tstart -> 0 [label = \"{}\"];\n", parse_state(m_automata.root()));
}

void RegexWriter::write_shapes() {
  for (RegexNode *node : m_automata.nodes()) {
    write("\t{} [shape = {}];\n", node->id, node->is_leaf() ? "doublecircle" : "circle");
  }
}

void RegexWriter::write_edges() {
  for (RegexNode *node : m_automata.nodes()) {
    for (RegexNode *edge : node->edges) {
      write("\t{} -> {} [label = \"{}\"];\n", node->id, edge->id, parse_state(node));
    }
  }
}

std::string_view RegexWriter::parse_state(RegexNode *node) {
  if (node->state == REGEX_EPSILON) {
    return "<$>";
  } else if (node->state == REGEX_ANY) {
    return "<^>";
  } else if (std::isspace(*node->state)) {
    return "<_>";
  } else if (!std::isprint(*node->state)) {
    return "<?>";
  } else if (*node->state == '"') {
    return "\"";
  } else {
    return {node->state, 1};
  }
}

}  // namespace sdata
